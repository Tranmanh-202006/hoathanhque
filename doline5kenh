#include <Arduino.h>

// ============================================================
// 1. CẤU HÌNH CHÂN (HARDWARE CONFIG)
// ============================================================
#define in1 18
#define in2 19
#define in3 21
#define in4 22
#define led 2 
#define ENA 16
#define ENB 23

// Cảm biến siêu âm
#define TRIG_PIN 26 
#define ECHO_PIN 27 

// Cảm biến dò line (5 mắt)
const int socambien = 5; 
int cambien[socambien] = {25, 34, 35, 32, 33};  
int value[socambien];   

// Cấu hình PWM ESP32
#define freq 5000
#define reslution 8
#define PWM_CHANNEL_A  0 
#define PWM_CHANNEL_B  1

// ============================================================
// 2. BIẾN TOÀN CỤC (GLOBAL VARIABLES)
// ============================================================

// --- CÀI ĐẶT LỘ TRÌNH (Tinh chỉnh số này theo thực tế) ---
const int TARGET_SO_VACH_DUT = 6; // Số vạch đứt cần đi qua trước khi rẽ lên dốc

// --- Biến Logic ---
int dem_T = 0;              // Đếm ngã ba (cho các đoạn đường thường)
int huong_lech_cuoi = 0;    // Nhớ hướng lệch khi mất line
bool da_qua_vat_can = false;// Cờ báo đã vượt vật cản
int dem_net_dut = 0;        // Biến đếm số vạch đứt đã qua
bool dang_tren_line = false;// Trạng thái để đếm nét đứt
bool che_do_leo_doc = false;// Cờ kích hoạt chế độ leo dốc (Max speed)

// --- PID Control ---
float kp = 36;   
float ki = 0.036;
float kd = 18; 

// PID riêng cho leo dốc (Cần mạnh hơn để giữ thẳng)
float kp_doc = 60; 
float kd_doc = 30;

float setpoint = 0.0; 
float read_last_value = 0.0; 
unsigned long last_timer = 0;
float last_error = 0;
float tichphan = 0;

// --- Tốc độ ---
int tocdo_chuan = 190;    
int tocdo_cham = 140;     
int tocdo_len_doc = 255;  
int tocdo_hien_tai = 190; 
int tocdoc_max = 255; 

// ============================================================
// 3. KHAI BÁO HÀM (PROTOTYPES)
// ============================================================
void doc_cambien(); 
void dieukhiendongco();
void stop();
void ham_phanh(int duration); 
void tien(int left, int right);
void phai(int speed); 
void trai(int speed); 
void lui(int left, int right);
void tinh_toan_loi();
float getDistance();
void re_trai_90_do(); 
void re_phai_90_do();
void xu_ly_mat_line();
void tranh_vat_can();
void bang_qua_net_dut(); 

// ============================================================
// 4. SETUP
// ============================================================
void setup(){
  Serial.begin(9600);
  
  // Setup PWM
  ledcSetup(PWM_CHANNEL_A, freq, reslution);
  ledcSetup(PWM_CHANNEL_B, freq, reslution);
  ledcAttachPin(ENA, PWM_CHANNEL_A);
  ledcAttachPin(ENB, PWM_CHANNEL_B);

  // Setup IO
  pinMode(led, OUTPUT);
  pinMode(in1, OUTPUT);
  pinMode(in2, OUTPUT);
  pinMode(in3, OUTPUT);
  pinMode(in4, OUTPUT);
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  stop();

  for(int i = 0; i < socambien; i++){
    pinMode(cambien[i], INPUT);
  }
}

// ============================================================
// 5. LOOP
// ============================================================
void loop(){
  dieukhiendongco();
}

// ============================================================
// 6. CÁC HÀM XỬ LÝ LOGIC (LOGIC FUNCTIONS)
// ============================================================

void doc_cambien() {
  for(int i = 0; i < socambien; i++){
    value[i] = digitalRead(cambien[i]);                   
  }
}

float getDistance() {
  digitalWrite(TRIG_PIN, LOW); delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH); delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);
  long d = pulseIn(ECHO_PIN, HIGH, 5000); // Timeout 5ms ~ 80cm
  if(d == 0) return 999; 
  return d * 0.034 / 2;
}

// Hàm tính lỗi và đếm vạch đứt
void tinh_toan_loi() {
  doc_cambien(); 
  float error_sum = 0;
  int active_sensors = 0;
  
  // Trọng số: -2, -1, 0, 1, 2
  if (value[0] == 0) { error_sum -= 2; active_sensors++; } 
  if (value[1] == 0) { error_sum -= 1; active_sensors++; } 
  if (value[2] == 0) { error_sum += 0; active_sensors++; } 
  if (value[3] == 0) { error_sum += 1; active_sensors++; } 
  if (value[4] == 0) { error_sum += 2; active_sensors++; } 

  if (active_sensors > 0) {
    read_last_value = error_sum / active_sensors;
    
    // Cập nhật hướng lệch cuối cùng để xử lý khi mất line
    if (read_last_value < -0.5) huong_lech_cuoi = -1; 
    else if (read_last_value > 0.5) huong_lech_cuoi = 1; 
    
    // --- LOGIC ĐẾM NÉT ĐỨT ---
    // Nếu trước đó đang mất line (trắng) mà giờ thấy line (đen) -> Mới vào 1 vạch
    if (!dang_tren_line && da_qua_vat_can) {
        dem_net_dut++;
        dang_tren_line = true; 
    }
  } else {
    // Không thấy cảm biến nào (vùng trắng giữa các nét đứt)
    dang_tren_line = false;
  }
}

float controller_pid(float setvalue, float readvalue, float kp_in, float ki_in, float kd_in){
  unsigned long now_timer = millis();
  float dt = (now_timer - last_timer) / 1000.0;
  if(dt <= 0) dt = 0.001;

  float error = setvalue - readvalue;
  tichphan += error * dt;
  tichphan = constrain(tichphan, -50, 50); 

  float daoham = (error - last_error) / dt;
  float output = (kp_in * error) + (ki_in * tichphan) + (kd_in * daoham);

  last_error = error;
  last_timer = now_timer;

  return output;
}

// ============================================================
// 7. TRUNG TÂM ĐIỀU KHIỂN (CORE LOGIC)
// ============================================================
void dieukhiendongco(){
  tinh_toan_loi(); 
  
  // --- A. QUẢN LÝ TỐC ĐỘ THEO TRẠNG THÁI ---
  if (che_do_leo_doc) {
      tocdo_hien_tai = tocdo_len_doc; // Max tốc độ khi leo dốc
  } 
  else if (da_qua_vat_can && dem_net_dut >= TARGET_SO_VACH_DUT) {
      tocdo_hien_tai = tocdo_chuan;   // Chuẩn bị rẽ
  }
  else if (da_qua_vat_can && dem_net_dut > 0) {
      tocdo_hien_tai = tocdo_cham;    // Đang đi nét đứt -> đi chậm
  } else {
      tocdo_hien_tai = tocdo_chuan;   // Mặc định
  }

  // --- B. XỬ LÝ NGÃ 4 / CHỮ X (Ưu tiên cao nhất) ---
  // Điều kiện: 5 mắt đen HOẶC (Mắt 1, 3, 5 đen - Chữ X)
  if ((value[0] == 0 && value[1] == 0 && value[2] == 0 && value[3] == 0 && value[4] == 0) || 
      (value[0] == 0 && value[4] == 0 && value[2] == 0)) { 
      
      tien(che_do_leo_doc ? 255 : 200, che_do_leo_doc ? 255 : 200);
      delay(200); // Vượt qua vạch ngang
      return; 
  }

  // --- C. XỬ LÝ NGÃ RẼ PHẢI (LOGIC LỘ TRÌNH LEO DỐC) ---
  // Phát hiện góc vuông phải (Mắt 3,4,5 đen)
  else if (value[4] == 0 && value[3] == 0 && value[2] == 0 && value[1] == 1 && value[0] == 1) {
      
      // >>> ĐIỂM QUAN TRỌNG: KÍCH HOẠT LEO DỐC <<<
      // Nếu đã qua vật cản VÀ đã đi hết đường nét đứt VÀ chưa leo dốc
      if (da_qua_vat_can == true && dem_net_dut >= TARGET_SO_VACH_DUT && che_do_leo_doc == false) {
          dem_T ++;
          if(dem_T == 2){
            delay(200);
            trai(120);
            unsigned long s = millis();
            while (digitalRead(cambien[2]) == 1 && digitalRead(cambien[1]) == 1) { 
            stop();
            delay(50); 
            if(millis() - s > 1500) break; 
           }
           che_do_leo_doc = true;
           tien(255, 255);
           delay(300);
            return;
          }
          // re_phai_90_do(); 
          //       // 1. Rẽ phải 90 độ
          // che_do_leo_doc = true; // 2. Bật chế độ leo dốc
          
          // // 3. Tăng tốc lấy đà ngay lập tức
          // tien(255, 255);
          // delay(400); 
          // return;
      }

      // Xử lý ngã rẽ thường (nếu chưa vào lộ trình leo dốc)
      if (!che_do_leo_doc) {
          dem_T++; 
          if (dem_T == 5) { // Logic cũ của bạn
             phai(250); delay(500);
          } else {
             tien(200, 200); delay(200); // Đi thẳng qua các ngã rẽ phụ
          }
      } else {
          // Đang leo dốc gặp nhánh phải -> Đi thẳng tiếp
          tien(255, 255);
      }
      return;
  } 

  // --- D. XỬ LÝ NGÃ RẼ TRÁI ---
  else if (value[0] == 0 && value[1] == 0 && value[2] == 0 && value[3] == 1 && value[4] == 1) {
      if (!che_do_leo_doc) {
          dem_T++;
          if (dem_T == 5) { // Logic cũ của bạn
              trai(250); delay(600); 
          } else {
              tien(170, 170); delay(200); 
          }
      } else {
          tien(255, 255); // Leo dốc thì đi thẳng
      }
      return;
  }

  // --- E. XỬ LÝ MẤT LINE ---
  if(value[0] == 1 && value[1] == 1 && value[2] == 1 && value[3] == 1 && value[4] == 1){
      if (che_do_leo_doc) {
          // Leo dốc mà mất line -> Vẫn ủi thẳng để lên đỉnh
          tien(255, 255);
      } else {
          xu_ly_mat_line();
      }
      return;
  }

  // --- F. QUÉT VẬT CẢN (Chỉ quét khi chưa leo dốc & chưa qua vật cản) ---
  static unsigned long last_check_sonar = 0;
  if (da_qua_vat_can == false && !che_do_leo_doc && (millis() - last_check_sonar > 60)) { 
      float distance = getDistance();
      if (distance > 0 && distance < 20) { // < 20cm thì né
          tranh_vat_can();
          return;
      }
      last_check_sonar = millis();
  }

  // --- G. GÓC GẮT (Override PID) ---
  if (value[0] == 0 && value[1] == 1 && value[2] == 1) { trai(che_do_leo_doc ? 255:180); return; }
  if (value[4] == 0 && value[3] == 1 && value[2] == 1) { phai(che_do_leo_doc ? 255:180); return; }

  // --- H. CHẠY PID ---
  digitalWrite(led, HIGH);
  
  // Chọn bộ tham số PID: Leo dốc dùng bộ mạnh hơn, đường bằng dùng bộ thường
  float use_kp = che_do_leo_doc ? kp_doc : kp;
  float use_kd = che_do_leo_doc ? kd_doc : kd;

  float output_pid = controller_pid(setpoint, read_last_value, use_kp, ki, use_kd);
  
  int left_motor = tocdo_hien_tai - output_pid;  
  int right_motor = tocdo_hien_tai + output_pid; 
  
  // Giới hạn PWM
  left_motor = constrain(left_motor, -150, tocdoc_max); 
  right_motor = constrain(right_motor, -150, tocdoc_max);

  // Xuất xung động cơ
  if (left_motor >= 0 && right_motor >= 0) {
      tien(left_motor, right_motor);
  } else if (left_motor < 0) {
      digitalWrite(in1, HIGH); digitalWrite(in2, LOW); ledcWrite(PWM_CHANNEL_A, abs(left_motor));
      digitalWrite(in3, HIGH); digitalWrite(in4, LOW); ledcWrite(PWM_CHANNEL_B, right_motor);
  } else if (right_motor < 0) {
      digitalWrite(in1, LOW); digitalWrite(in2, HIGH); ledcWrite(PWM_CHANNEL_A, left_motor);
      digitalWrite(in3, LOW); digitalWrite(in4, HIGH); ledcWrite(PWM_CHANNEL_B, abs(right_motor));
  }
}

// ============================================================
// 8. CÁC HÀM ĐIỀU KHIỂN ĐỘNG CƠ & HÀNH VI
// ============================================================

void stop(){
  digitalWrite(in1, LOW); digitalWrite(in2, LOW);
  digitalWrite(in3, LOW); digitalWrite(in4, LOW);
  ledcWrite(PWM_CHANNEL_A, 0); ledcWrite(PWM_CHANNEL_B, 0);
}

void tien(int left, int right){
  ledcWrite(PWM_CHANNEL_A, left); ledcWrite(PWM_CHANNEL_B, right);
  digitalWrite(in1, LOW); digitalWrite(in2, HIGH);
  digitalWrite(in3, HIGH); digitalWrite(in4, LOW);
}

void phai(int speed){ 
  ledcWrite(PWM_CHANNEL_A, speed); ledcWrite(PWM_CHANNEL_B, speed);
  digitalWrite(in1, LOW); digitalWrite(in2, HIGH); 
  digitalWrite(in3, LOW); digitalWrite(in4, HIGH); 
}

void trai(int speed){ 
  ledcWrite(PWM_CHANNEL_A, speed); ledcWrite(PWM_CHANNEL_B, speed);
  digitalWrite(in1, HIGH); digitalWrite(in2, LOW); 
  digitalWrite(in3, HIGH); digitalWrite(in4, LOW); 
}

void lui(int left, int right){
  ledcWrite(PWM_CHANNEL_A, left); ledcWrite(PWM_CHANNEL_B, right);
  digitalWrite(in1, HIGH); digitalWrite(in2, LOW);
  digitalWrite(in3, LOW); digitalWrite(in4, HIGH);
}

void ham_phanh(int duration) {
  lui(255, 255); 
  delay(duration);
  stop();
}

void re_trai_90_do() {
  ham_phanh(100); 
  trai(200); 
  delay(200); // Xoay mù một chút để thoát line hiện tại
  while(digitalRead(cambien[2]) == 1) { 
    // Chờ mắt giữa gặp vạch đen
  } 
  stop(); 
}

void re_phai_90_do() {
  ham_phanh(100); 
  phai(200); 
  delay(200); 
  while(digitalRead(cambien[2]) == 1) {
    // Chờ mắt giữa gặp vạch đen
  } 
  stop(); 
}

void xu_ly_mat_line() {
    // Nếu trong đoạn nét đứt thì đi thẳng một chút để tìm vạch tiếp theo
    if (da_qua_vat_can == true && dem_net_dut <= TARGET_SO_VACH_DUT) { 
        bang_qua_net_dut();
        return; 
    }

    digitalWrite(led, LOW);
    ham_phanh(80); 
    
    // Tìm lại line dựa trên hướng lệch cuối cùng
    if (huong_lech_cuoi == -1) {
        trai(160); delay(100); 
        unsigned long s = millis();
        while (digitalRead(cambien[2]) == 1 && digitalRead(cambien[1]) == 1) { 
            trai(150); 
            if(millis() - s > 1500) break; 
        }
    } else {
        phai(160); delay(100);
        unsigned long s = millis();
        while (digitalRead(cambien[2]) == 1 && digitalRead(cambien[3]) == 1) { 
            phai(150);
            if(millis() - s > 1500) break;
        }
    }
    stop(); delay(50);
}

void bang_qua_net_dut() {
    // Chỉ điều chỉnh nhẹ hướng đi, chủ yếu là tiến thẳng
    if (huong_lech_cuoi == -1) tien(140, 160); 
    else if (huong_lech_cuoi == 1) tien(160, 140); 
    else tien(140, 140);
    delay(1350);
    re_phai_90_do();
    // Không delay lớn ở đây để vòng loop tiếp tục quét cảm biến đếm vạch
}

void tranh_vat_can() {
    stop(); delay(100);
    // 1. Lùi lại
    lui(150, 150); delay(200); stop(); delay(50);
    // 2. Rẽ trái né
    trai(180); delay(500); stop(); delay(50);
    // 3. Đi thẳng song song
    tien(160, 160); delay(450); stop(); delay(50);
    // 4. Rẽ phải để về line
    phai(180); delay(500); stop(); delay(50);
    
    // 5. Tìm lại line
    unsigned long start_time = millis();
    bool found_line = false;
    tien(140, 140);
    while (millis() - start_time < 2000) {
        doc_cambien();
        if (value[0] == 0 || value[1] == 0 || value[2] == 0 || value[3] == 0 || value[4] == 0) {
            found_line = true; break;
        }
    }
    stop(); delay(100);
    
    // 6. Cập nhật trạng thái
    if (found_line) {
        tien(120, 120); delay(200); // Nhích thêm chút để ổn định
        da_qua_vat_can = true;      // Đánh dấu đã xong vật cản
        dem_net_dut = 0;            // Reset biến đếm nét đứt để bắt đầu đếm
    }
}
